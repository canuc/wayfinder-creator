<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>openclaw creator</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  :root {
    --bg: #09090b;
    --bg-raised: #111113;
    --bg-input: #0c0c0e;
    --surface: #18181b;
    --border: #27272a;
    --border-hover: #3f3f46;
    --accent: #22c55e;
    --accent-muted: rgba(34, 197, 94, 0.15);
    --accent-text: #4ade80;
    --red: #ef4444;
    --red-muted: rgba(239, 68, 68, 0.12);
    --yellow: #eab308;
    --yellow-muted: rgba(234, 179, 8, 0.12);
    --cyan: #06b6d4;
    --text: #fafafa;
    --text-secondary: #a1a1aa;
    --text-tertiary: #52525b;
    --mono: 'JetBrains Mono', monospace;
    --sans: 'Inter', -apple-system, system-ui, sans-serif;
    --radius: 8px;
    --radius-lg: 12px;
  }

  body {
    font-family: var(--sans);
    background: var(--bg);
    color: var(--text);
    min-height: 100vh;
    line-height: 1.5;
    -webkit-font-smoothing: antialiased;
  }

  .container {
    max-width: 780px;
    margin: 0 auto;
    padding: 3rem 1.5rem 4rem;
  }

  /* Header */
  header {
    margin-bottom: 2.5rem;
  }

  .logo-row {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 4px;
  }

  .logo-mark {
    width: 28px;
    height: 28px;
    border-radius: 6px;
    background: linear-gradient(135deg, var(--accent) 0%, #16a34a 100%);
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: var(--mono);
    font-weight: 600;
    font-size: 14px;
    color: #000;
  }

  h1 {
    font-family: var(--sans);
    font-size: 1.25rem;
    font-weight: 600;
    color: var(--text);
    letter-spacing: -0.02em;
  }

  h1 span {
    color: var(--text-tertiary);
    font-weight: 400;
  }

  .subtitle {
    font-size: 0.8rem;
    color: var(--text-tertiary);
    margin-top: 2px;
  }

  /* Sections */
  .section-label {
    font-size: 0.7rem;
    font-weight: 500;
    color: var(--text-tertiary);
    text-transform: uppercase;
    letter-spacing: 0.08em;
    margin-bottom: 0.75rem;
  }

  /* Card */
  .card {
    background: var(--bg-raised);
    border: 1px solid var(--border);
    border-radius: var(--radius-lg);
    padding: 1.5rem;
    margin-bottom: 1.75rem;
  }

  /* Form */
  .form-grid {
    display: grid;
    gap: 1rem;
  }

  .form-row {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 1rem;
  }

  label {
    display: block;
    font-size: 0.75rem;
    font-weight: 500;
    color: var(--text-secondary);
    margin-bottom: 6px;
  }

  label .hint {
    color: var(--text-tertiary);
    font-weight: 400;
  }

  select {
    width: 100%;
    background: var(--bg-input);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    color: var(--text);
    font-family: var(--sans);
    font-size: 0.8rem;
    padding: 0.55rem 0.75rem;
    transition: border-color 0.15s, box-shadow 0.15s;
    cursor: pointer;
    appearance: none;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='%2352525b' viewBox='0 0 16 16'%3E%3Cpath d='M8 11L3 6h10z'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 10px center;
  }

  select:focus {
    outline: none;
    border-color: var(--accent);
    box-shadow: 0 0 0 3px var(--accent-muted);
  }

  select option {
    background: var(--surface);
    color: var(--text);
  }

  input, textarea {
    width: 100%;
    background: var(--bg-input);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    color: var(--text);
    font-family: var(--mono);
    font-size: 0.8rem;
    padding: 0.55rem 0.75rem;
    transition: border-color 0.15s, box-shadow 0.15s;
  }

  input::placeholder, textarea::placeholder {
    color: var(--text-tertiary);
  }

  input:focus, textarea:focus {
    outline: none;
    border-color: var(--accent);
    box-shadow: 0 0 0 3px var(--accent-muted);
  }

  textarea {
    resize: vertical;
    min-height: 72px;
    line-height: 1.5;
  }

  .input-wrap {
    position: relative;
  }

  .input-wrap .toggle-vis {
    position: absolute;
    right: 8px;
    top: 50%;
    transform: translateY(-50%);
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 4px;
    color: var(--text-tertiary);
    cursor: pointer;
    font-family: var(--mono);
    font-size: 0.6rem;
    padding: 2px 6px;
    transition: color 0.15s, border-color 0.15s;
  }

  .input-wrap .toggle-vis:hover {
    color: var(--text-secondary);
    border-color: var(--border-hover);
  }

  /* Buttons */
  .btn {
    font-family: var(--sans);
    font-size: 0.8rem;
    font-weight: 500;
    border: none;
    border-radius: var(--radius);
    padding: 0.55rem 1.25rem;
    cursor: pointer;
    transition: all 0.15s;
    display: inline-flex;
    align-items: center;
    gap: 6px;
  }

  .btn-primary {
    background: var(--accent);
    color: #000;
  }

  .btn-primary:hover:not(:disabled) {
    background: #16a34a;
  }

  .btn-primary:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .btn-ghost {
    background: transparent;
    color: var(--text-tertiary);
    border: 1px solid var(--border);
    font-size: 0.7rem;
    padding: 0.3rem 0.6rem;
    border-radius: 6px;
  }

  .btn-ghost:hover {
    color: var(--red);
    border-color: var(--red);
    background: var(--red-muted);
  }

  .btn-warn {
    background: transparent;
    color: var(--yellow);
    border: 1px solid var(--yellow);
    font-family: var(--sans);
    font-size: 0.75rem;
    font-weight: 500;
    padding: 0.45rem 1rem;
    border-radius: var(--radius);
    cursor: pointer;
    transition: all 0.15s;
  }

  .btn-warn:hover:not(:disabled) {
    background: var(--yellow-muted);
  }

  .btn-warn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .actions {
    margin-top: 1.25rem;
    display: flex;
    align-items: center;
    gap: 1rem;
  }

  /* Status message */
  .status-msg {
    font-size: 0.75rem;
    padding: 0.6rem 0.85rem;
    border-radius: var(--radius);
    margin-top: 1rem;
    display: none;
  }

  .status-msg.show { display: block; }
  .status-msg.ok { color: var(--accent-text); background: var(--accent-muted); }
  .status-msg.err { color: #fca5a5; background: var(--red-muted); }

  /* Table */
  .table-wrap {
    overflow-x: auto;
  }

  table {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.8rem;
  }

  th {
    text-align: left;
    color: var(--text-tertiary);
    font-weight: 500;
    font-size: 0.7rem;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    padding: 0 0.75rem 0.6rem;
    border-bottom: 1px solid var(--border);
    white-space: nowrap;
  }

  td {
    padding: 0.65rem 0.75rem;
    border-bottom: 1px solid rgba(39, 39, 42, 0.5);
    white-space: nowrap;
    font-family: var(--mono);
    font-size: 0.75rem;
    color: var(--text-secondary);
  }

  tr:last-child td {
    border-bottom: none;
  }

  tr:hover td {
    background: rgba(255, 255, 255, 0.02);
  }

  td.name-col {
    color: var(--text);
    font-family: var(--sans);
    font-weight: 500;
  }

  .status-pill {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    padding: 0.2rem 0.55rem;
    border-radius: 100px;
    font-family: var(--sans);
    font-size: 0.7rem;
    font-weight: 500;
  }

  .status-pill .dot {
    width: 6px;
    height: 6px;
    border-radius: 50%;
    flex-shrink: 0;
  }

  .status-provisioning {
    color: var(--yellow);
    background: var(--yellow-muted);
  }
  .status-provisioning .dot {
    background: var(--yellow);
    animation: pulse-dot 1.5s ease-in-out infinite;
  }

  @keyframes pulse-dot {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.3; }
  }

  .status-ready {
    color: var(--accent-text);
    background: var(--accent-muted);
  }
  .status-ready .dot { background: var(--accent); }

  .status-failed {
    color: #fca5a5;
    background: var(--red-muted);
  }
  .status-failed .dot { background: var(--red); }

  .empty-state {
    color: var(--text-tertiary);
    font-size: 0.8rem;
    padding: 2.5rem 1rem;
    text-align: center;
  }

  .wallet {
    color: var(--cyan);
    font-size: 0.7rem;
  }

  /* Channels */
  .channel-row {
    display: grid;
    grid-template-columns: 140px 1fr auto;
    gap: 0.5rem;
    align-items: end;
    margin-bottom: 0.5rem;
  }

  .channel-row select,
  .channel-row input {
    font-size: 0.75rem;
    padding: 0.45rem 0.6rem;
  }

  .channel-row .btn-remove {
    background: transparent;
    border: 1px solid var(--border);
    border-radius: var(--radius);
    color: var(--text-tertiary);
    cursor: pointer;
    font-size: 0.7rem;
    padding: 0.45rem 0.5rem;
    transition: color 0.15s, border-color 0.15s;
  }

  .channel-row .btn-remove:hover {
    color: var(--red);
    border-color: var(--red);
  }

  .btn-add-channel {
    background: transparent;
    border: 1px dashed var(--border);
    border-radius: var(--radius);
    color: var(--text-tertiary);
    cursor: pointer;
    font-family: var(--sans);
    font-size: 0.75rem;
    padding: 0.4rem 0.75rem;
    transition: color 0.15s, border-color 0.15s;
    margin-top: 0.25rem;
  }

  .btn-add-channel:hover {
    color: var(--accent-text);
    border-color: var(--accent);
  }

  /* Creator key */
  .key-display {
    display: flex;
    align-items: start;
    gap: 0.5rem;
  }

  .key-display textarea {
    flex: 1;
    background: var(--bg-input);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    color: var(--text-secondary);
    font-family: var(--mono);
    font-size: 0.65rem;
    line-height: 1.4;
    padding: 0.5rem 0.65rem;
    resize: none;
    min-height: 0;
    height: auto;
  }

  .key-buttons {
    display: flex;
    flex-direction: column;
    gap: 0.3rem;
    flex-shrink: 0;
  }

  .btn-copy {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 6px;
    color: var(--text-tertiary);
    cursor: pointer;
    font-family: var(--mono);
    font-size: 0.6rem;
    padding: 0.35rem 0.55rem;
    white-space: nowrap;
    transition: color 0.15s, border-color 0.15s;
  }

  .btn-copy:hover {
    color: var(--text-secondary);
    border-color: var(--border-hover);
  }

  /* Pairing buttons */
  .btn-approve {
    background: var(--accent);
    color: #000;
    font-family: var(--sans);
    font-size: 0.7rem;
    font-weight: 500;
    border: none;
    border-radius: 6px;
    padding: 0.25rem 0.55rem;
    cursor: pointer;
    transition: background 0.15s;
  }

  .btn-approve:hover:not(:disabled) { background: #16a34a; }
  .btn-approve:disabled { opacity: 0.5; cursor: not-allowed; }

  .btn-deny {
    background: transparent;
    color: var(--red);
    border: 1px solid var(--red);
    font-family: var(--sans);
    font-size: 0.7rem;
    font-weight: 500;
    border-radius: 6px;
    padding: 0.25rem 0.55rem;
    cursor: pointer;
    transition: all 0.15s;
  }

  .btn-deny:hover:not(:disabled) { background: var(--red-muted); }
  .btn-deny:disabled { opacity: 0.5; cursor: not-allowed; }

  .pairing-actions {
    display: flex;
    gap: 0.4rem;
  }

  /* Log viewer */
  #log-view { display: none; }
  #log-view.active { display: block; }
  #main-view.hidden { display: none; }

  .log-header {
    display: flex;
    align-items: center;
    gap: 1rem;
    margin-bottom: 1rem;
  }

  .log-header .btn-back {
    background: transparent;
    border: 1px solid var(--border);
    border-radius: var(--radius);
    color: var(--text-secondary);
    cursor: pointer;
    font-family: var(--sans);
    font-size: 0.75rem;
    padding: 0.4rem 0.75rem;
    transition: color 0.15s, border-color 0.15s;
  }

  .log-header .btn-back:hover {
    color: var(--text);
    border-color: var(--border-hover);
  }

  .log-meta {
    font-size: 0.8rem;
    color: var(--text-secondary);
    margin-bottom: 1rem;
    display: flex;
    align-items: center;
    gap: 0.75rem;
    flex-wrap: wrap;
  }

  .log-meta .server-name {
    color: var(--text);
    font-weight: 500;
  }

  .log-meta .server-ip {
    font-family: var(--mono);
    font-size: 0.75rem;
    color: var(--text-tertiary);
  }

  .log-terminal {
    background: #050507;
    border: 1px solid var(--border);
    border-radius: var(--radius-lg);
    padding: 1rem;
    font-family: var(--mono);
    font-size: 0.75rem;
    line-height: 1.6;
    color: #c8c8d0;
    max-height: 70vh;
    overflow-y: auto;
    white-space: pre-wrap;
    word-break: break-all;
  }

  .log-terminal::-webkit-scrollbar {
    width: 6px;
  }

  .log-terminal::-webkit-scrollbar-track {
    background: transparent;
  }

  .log-terminal::-webkit-scrollbar-thumb {
    background: var(--border);
    border-radius: 3px;
  }

  .log-done-msg {
    margin-top: 0.75rem;
    font-size: 0.75rem;
    color: var(--text-tertiary);
    display: flex;
    align-items: center;
    gap: 1rem;
  }

  /* Clickable server name in table */
  .server-name-link {
    color: var(--text);
    text-decoration: none;
    cursor: pointer;
  }

  .server-name-link:hover {
    color: var(--accent-text);
    text-decoration: underline;
  }

  /* Footer */
  footer {
    margin-top: 3rem;
    padding-top: 1rem;
    border-top: 1px solid var(--border);
    font-size: 0.7rem;
    color: var(--text-tertiary);
    text-align: center;
  }

  /* responsive */
  @media (max-width: 640px) {
    .container { padding: 1.5rem 1rem 3rem; }
    .form-row { grid-template-columns: 1fr; }
    td, th { padding: 0.4rem 0.5rem; }
  }
</style>
</head>
<body>
<div class="container">
  <header>
    <div class="logo-row">
      <div class="logo-mark">oc</div>
      <h1>openclaw <span>creator</span></h1>
    </div>
    <div class="subtitle">Cloud server provisioning</div>
  </header>

  <div id="main-view">
    <section>
      <div class="section-label">Creator Key</div>
      <div class="card">
        <label>Your ECDSA P-256 public key <span class="hint">(stored in this browser, auto-generated)</span></label>
        <div class="key-display">
          <textarea id="creator-pubkey" readonly rows="4" spellcheck="false">Generating key...</textarea>
          <div class="key-buttons">
            <button type="button" class="btn-copy" id="copy-key-btn">copy</button>
            <button type="button" class="btn-copy" id="export-key-btn">export</button>
            <button type="button" class="btn-copy" id="import-key-btn">import</button>
          </div>
        </div>
      </div>
    </section>

    <section>
      <div class="section-label">Deploy</div>
      <div class="card">
        <form id="create-form">
          <div class="form-grid">
            <div>
              <label>Server name <span class="hint">(auto-generated if blank)</span></label>
              <input type="text" id="f-name" placeholder="claw-myserver" autocomplete="off" spellcheck="false">
            </div>
            <div>
              <label>SSH public key</label>
              <textarea id="f-ssh" placeholder="ssh-ed25519 AAAA..." spellcheck="false"></textarea>
            </div>
            <div class="form-row">
              <div>
                <label>AI provider</label>
                <select id="f-provider">
                  <option value="anthropic">Anthropic (Claude)</option>
                  <option value="openai">OpenAI (ChatGPT)</option>
                  <option value="gemini">Google Gemini</option>
                </select>
              </div>
              <div>
                <label id="provider-key-label">Anthropic API key</label>
                <div class="input-wrap">
                  <input type="password" id="f-provider-key" placeholder="sk-ant-api03-..." autocomplete="off" spellcheck="false">
                  <button type="button" class="toggle-vis" data-target="f-provider-key">show</button>
                </div>
              </div>
            </div>
            <div>
              <label>Wayfinder API key <span class="hint">(required)</span></label>
              <div class="input-wrap">
                <input type="password" id="f-wayfinder-key" placeholder="wf-..." autocomplete="off" spellcheck="false" required>
                <button type="button" class="toggle-vis" data-target="f-wayfinder-key">show</button>
              </div>
            </div>
            <div id="channels-section">
              <label>Channels <span class="hint">(optional)</span></label>
              <div id="channels-list"></div>
              <button type="button" class="btn-add-channel" id="add-channel-btn">+ Add channel</button>
            </div>
          </div>
          <div class="actions">
            <button type="submit" class="btn btn-primary" id="submit-btn">Deploy server</button>
          </div>
          <div class="status-msg" id="form-status"></div>
        </form>
      </div>
    </section>

    <section>
      <div class="section-label">Servers</div>
      <div class="card">
        <div class="table-wrap">
          <div id="server-list">
            <div class="empty-state">No servers running. Deploy one to get started.</div>
          </div>
        </div>
      </div>
    </section>

    <section id="pairing-section" style="display:none">
      <div class="section-label">Pairing Requests</div>
      <div class="card">
        <div class="table-wrap">
          <div id="pairing-list">
            <div class="empty-state">No pending pairing requests.</div>
          </div>
        </div>
      </div>
    </section>
  </div>

  <div id="log-view">
    <div class="log-header">
      <button class="btn-back" id="log-back-btn">&larr; Back</button>
      <span id="log-status-pill"></span>
    </div>
    <div class="log-meta">
      <span class="server-name" id="log-server-name"></span>
      <span class="server-ip" id="log-server-ip"></span>
    </div>
    <pre class="log-terminal" id="log-terminal"></pre>
    <div class="log-done-msg" id="log-done-msg"></div>
  </div>

  <footer>
    openclaw creator
  </footer>
</div>

<script>
(function () {
  'use strict';

  const API = '';
  let polling = null;
  let logWs = null;
  let currentLogServerId = null;
  let pairingPoll = null;

  // --- Crypto module: ECDSA P-256 key management + request signing ---

  function openKeyDB() {
    return new Promise((resolve, reject) => {
      const req = indexedDB.open('openclaw-creator-keys', 1);
      req.onupgradeneeded = () => {
        req.result.createObjectStore('keys');
      };
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });
  }

  async function generateAndStoreKeypair() {
    const keyPair = await crypto.subtle.generateKey(
      { name: 'ECDSA', namedCurve: 'P-256' },
      true, // extractable so key can be exported between browsers
      ['sign', 'verify']
    );

    // Export public key as SPKI PEM
    const spki = await crypto.subtle.exportKey('spki', keyPair.publicKey);
    const b64 = btoa(String.fromCharCode(...new Uint8Array(spki)));
    const pem = '-----BEGIN PUBLIC KEY-----\n' + b64.match(/.{1,64}/g).join('\n') + '\n-----END PUBLIC KEY-----\n';

    // Store in IndexedDB
    const db = await openKeyDB();
    await new Promise((resolve, reject) => {
      const tx = db.transaction('keys', 'readwrite');
      tx.objectStore('keys').put(keyPair.privateKey, 'privateKey');
      tx.objectStore('keys').put(pem, 'publicKeyPEM');
      tx.oncomplete = resolve;
      tx.onerror = () => reject(tx.error);
    });
    db.close();

    return { privateKey: keyPair.privateKey, publicKeyPEM: pem };
  }

  async function getOrCreateKeypair() {
    const db = await openKeyDB();
    const get = (key) => new Promise((resolve, reject) => {
      const tx = db.transaction('keys', 'readonly');
      const req = tx.objectStore('keys').get(key);
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });

    const privateKey = await get('privateKey');
    const publicKeyPEM = await get('publicKeyPEM');
    db.close();

    if (privateKey && publicKeyPEM) {
      return { privateKey, publicKeyPEM };
    }
    return generateAndStoreKeypair();
  }

  async function signRequest(method, path, body) {
    const { privateKey } = await getOrCreateKeypair();
    const timestamp = Math.floor(Date.now() / 1000).toString();

    let digest = '';
    if (body) {
      const encoded = new TextEncoder().encode(body);
      const hashBuf = await crypto.subtle.digest('SHA-256', encoded);
      digest = btoa(String.fromCharCode(...new Uint8Array(hashBuf)));
    }

    const signingString = method + '\n' + path + '\n' + timestamp + '\n' + digest;
    const sigBuf = await crypto.subtle.sign(
      { name: 'ECDSA', hash: 'SHA-256' },
      privateKey,
      new TextEncoder().encode(signingString)
    );

    // Convert DER signature to raw r||s (IEEE P1363 format, 64 bytes)
    const rawSig = derToRaw(new Uint8Array(sigBuf));
    const sigB64 = btoa(String.fromCharCode(...rawSig));

    return {
      'X-Signature': sigB64,
      'X-Signature-Timestamp': timestamp,
      'X-Content-Digest': digest,
      'X-Signature-Method': 'ECDSA-P256-SHA256',
    };
  }

  function derToRaw(der) {
    // WebCrypto ECDSA returns DER-encoded signatures
    // Parse ASN.1 SEQUENCE { INTEGER r, INTEGER s } -> raw r||s (32 bytes each)
    if (der[0] !== 0x30) return der; // not DER, assume already raw
    let offset = 2;
    if (der[1] & 0x80) offset += (der[1] & 0x7f);

    // Parse r
    if (der[offset] !== 0x02) return der;
    const rLen = der[offset + 1];
    let rStart = offset + 2;
    let rBytes = der.slice(rStart, rStart + rLen);
    offset = rStart + rLen;

    // Parse s
    if (der[offset] !== 0x02) return der;
    const sLen = der[offset + 1];
    let sStart = offset + 2;
    let sBytes = der.slice(sStart, sStart + sLen);

    // Trim leading zeros and pad to 32 bytes
    function pad32(bytes) {
      while (bytes.length > 32 && bytes[0] === 0) bytes = bytes.slice(1);
      const out = new Uint8Array(32);
      out.set(bytes, 32 - bytes.length);
      return out;
    }

    const raw = new Uint8Array(64);
    raw.set(pad32(rBytes), 0);
    raw.set(pad32(sBytes), 32);
    return raw;
  }

  async function signedFetch(creatorPath, nodePath, method, body) {
    const headers = await signRequest(method, nodePath, body || '');
    const opts = { method, headers: { ...headers } };
    if (body) {
      opts.headers['Content-Type'] = 'application/json';
      opts.body = body;
    }
    return fetch(API + creatorPath, opts);
  }

  async function exportKeypairJSON() {
    const { privateKey } = await getOrCreateKeypair();
    const jwk = await crypto.subtle.exportKey('jwk', privateKey);
    return JSON.stringify(jwk);
  }

  async function importKeypairJSON(jsonStr) {
    const jwk = JSON.parse(jsonStr);

    // Import as private key (sign)
    const privateKey = await crypto.subtle.importKey(
      'jwk', jwk,
      { name: 'ECDSA', namedCurve: 'P-256' },
      true,
      ['sign']
    );

    // Derive the public key PEM from the JWK (strip d to get public-only JWK, import, export as SPKI)
    const pubJwk = { kty: jwk.kty, crv: jwk.crv, x: jwk.x, y: jwk.y };
    const publicKey = await crypto.subtle.importKey(
      'jwk', pubJwk,
      { name: 'ECDSA', namedCurve: 'P-256' },
      true,
      ['verify']
    );
    const spki = await crypto.subtle.exportKey('spki', publicKey);
    const b64 = btoa(String.fromCharCode(...new Uint8Array(spki)));
    const pem = '-----BEGIN PUBLIC KEY-----\n' + b64.match(/.{1,64}/g).join('\n') + '\n-----END PUBLIC KEY-----\n';

    // Store in IndexedDB (replaces existing)
    const db = await openKeyDB();
    await new Promise((resolve, reject) => {
      const tx = db.transaction('keys', 'readwrite');
      tx.objectStore('keys').put(privateKey, 'privateKey');
      tx.objectStore('keys').put(pem, 'publicKeyPEM');
      tx.oncomplete = resolve;
      tx.onerror = () => reject(tx.error);
    });
    db.close();

    return { privateKey, publicKeyPEM: pem };
  }

  // --- Initialize keypair on page load ---
  let cachedKeypair = null;

  async function initKeypair() {
    try {
      cachedKeypair = await getOrCreateKeypair();
      document.getElementById('creator-pubkey').value = cachedKeypair.publicKeyPEM;
    } catch (err) {
      document.getElementById('creator-pubkey').value = 'Error: ' + err.message;
      console.error('keypair init failed:', err);
    }
  }

  initKeypair();

  document.getElementById('copy-key-btn').addEventListener('click', function () {
    const ta = document.getElementById('creator-pubkey');
    navigator.clipboard.writeText(ta.value).then(() => {
      this.textContent = 'copied';
      setTimeout(() => { this.textContent = 'copy'; }, 2000);
    });
  });

  document.getElementById('export-key-btn').addEventListener('click', async function () {
    try {
      const json = await exportKeypairJSON();
      const blob = new Blob([json], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'openclaw-creator-key.json';
      a.click();
      URL.revokeObjectURL(url);
    } catch (err) {
      alert('Export failed: ' + err.message);
    }
  });

  document.getElementById('import-key-btn').addEventListener('click', function () {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json,application/json';
    input.addEventListener('change', async function () {
      const file = input.files[0];
      if (!file) return;
      try {
        const json = await file.text();
        cachedKeypair = await importKeypairJSON(json);
        document.getElementById('creator-pubkey').value = cachedKeypair.publicKeyPEM;
      } catch (err) {
        alert('Import failed: ' + err.message);
      }
    });
    input.click();
  });

  // Toggle password visibility
  document.querySelectorAll('.toggle-vis').forEach(btn => {
    btn.addEventListener('click', () => {
      const input = document.getElementById(btn.dataset.target);
      if (input.type === 'password') {
        input.type = 'text';
        btn.textContent = 'hide';
      } else {
        input.type = 'password';
        btn.textContent = 'show';
      }
    });
  });

  // Provider dropdown -> update key label and placeholder
  const providerMeta = {
    anthropic: { label: 'Anthropic API key', placeholder: 'sk-ant-api03-...' },
    openai: { label: 'OpenAI API key', placeholder: 'sk-...' },
    gemini: { label: 'Gemini API key', placeholder: 'AI...' },
  };
  document.getElementById('f-provider').addEventListener('change', function () {
    const m = providerMeta[this.value] || providerMeta.anthropic;
    document.getElementById('provider-key-label').textContent = m.label;
    const input = document.getElementById('f-provider-key');
    input.placeholder = m.placeholder;
    input.value = '';
  });

  // Dynamic channels
  let channelCount = 0;
  const channelTypes = ['telegram', 'discord', 'slack', 'whatsapp', 'signal', 'googlechat', 'mattermost'];

  document.getElementById('add-channel-btn').addEventListener('click', addChannelRow);

  function addChannelRow() {
    channelCount++;
    const id = channelCount;
    const row = document.createElement('div');
    row.className = 'channel-row';
    row.dataset.channelId = id;
    row.innerHTML =
      '<select data-field="type">' + channelTypes.map(t => '<option value="' + t + '">' + t.charAt(0).toUpperCase() + t.slice(1) + '</option>').join('') + '</select>' +
      '<div class="input-wrap"><input type="password" data-field="token" placeholder="bot token..." autocomplete="off" spellcheck="false"><button type="button" class="toggle-vis" data-target="ch-tok-' + id + '">show</button></div>' +
      '<button type="button" class="btn-remove">&times;</button>';
    row.querySelector('input').id = 'ch-tok-' + id;
    row.querySelector('.btn-remove').addEventListener('click', () => row.remove());
    row.querySelector('.toggle-vis').addEventListener('click', function () {
      const inp = document.getElementById(this.dataset.target);
      if (inp.type === 'password') { inp.type = 'text'; this.textContent = 'hide'; }
      else { inp.type = 'password'; this.textContent = 'show'; }
    });
    document.getElementById('channels-list').appendChild(row);
  }

  function getChannels() {
    const rows = document.querySelectorAll('.channel-row');
    const channels = [];
    rows.forEach(row => {
      const type = row.querySelector('[data-field="type"]').value;
      const token = row.querySelector('[data-field="token"]').value.trim();
      if (type && token) channels.push({ type, token });
    });
    return channels;
  }

  // Form submission
  const form = document.getElementById('create-form');
  const submitBtn = document.getElementById('submit-btn');
  const statusEl = document.getElementById('form-status');

  function showStatus(msg, ok) {
    statusEl.textContent = msg;
    statusEl.className = 'status-msg show ' + (ok ? 'ok' : 'err');
    if (ok) setTimeout(() => { statusEl.className = 'status-msg'; }, 5000);
  }

  form.addEventListener('submit', async (e) => {
    e.preventDefault();
    submitBtn.disabled = true;
    submitBtn.textContent = 'Deploying...';
    statusEl.className = 'status-msg';

    const body = {};
    const name = document.getElementById('f-name').value.trim();
    const ssh = document.getElementById('f-ssh').value.trim();
    const provider = document.getElementById('f-provider').value;
    const providerKey = document.getElementById('f-provider-key').value.trim();
    const wayfinderKey = document.getElementById('f-wayfinder-key').value.trim();
    const channels = getChannels();

    if (!wayfinderKey) {
      showStatus('Wayfinder API key is required', false);
      submitBtn.disabled = false;
      submitBtn.textContent = 'Deploy server';
      return;
    }

    // Include the creator public key (always available from page load)
    if (cachedKeypair) {
      body.public_key_pem = cachedKeypair.publicKeyPEM;
    } else {
      try {
        cachedKeypair = await getOrCreateKeypair();
        body.public_key_pem = cachedKeypair.publicKeyPEM;
      } catch (err) {
        console.error('keypair retrieval failed:', err);
      }
    }

    if (name) body.name = name;
    if (ssh) body.ssh_public_key = ssh;
    body.wayfinder_api_key = wayfinderKey;
    if (providerKey) {
      if (provider === 'anthropic') body.anthropic_api_key = providerKey;
      else if (provider === 'openai') body.openai_api_key = providerKey;
      else if (provider === 'gemini') body.gemini_api_key = providerKey;
    }
    if (channels.length > 0) body.channels = channels;

    try {
      const res = await fetch(API + '/servers', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body),
      });
      const data = await res.json();
      if (!res.ok) {
        showStatus('Error: ' + (data.error || res.statusText), false);
        return;
      }
      form.reset();
      refreshServers();
      startPolling();
      showLogView(data.id, data.name, data.ipv4 || '');
    } catch (err) {
      showStatus('Network error: ' + err.message, false);
    } finally {
      submitBtn.disabled = false;
      submitBtn.textContent = 'Deploy server';
    }
  });

  // Server list
  async function refreshServers() {
    try {
      const res = await fetch(API + '/servers');
      if (!res.ok) return;
      const servers = await res.json();
      lastServers = servers;
      renderServers(servers);

      const hasProvisioning = servers.some(s => s.status === 'provisioning');
      if (hasProvisioning && !polling) startPolling();
      if (!hasProvisioning && polling) stopPolling();

      const hasNodeAPI = servers.some(s => s.status === 'ready' && s.has_node_api);
      if (hasNodeAPI) startPairingPoll();
      else stopPairingPoll();
    } catch (_) {}
  }

  function renderServers(servers) {
    const el = document.getElementById('server-list');
    if (!servers || servers.length === 0) {
      el.innerHTML = '<div class="empty-state">No servers running. Deploy one to get started.</div>';
      return;
    }

    let html = '<table><thead><tr>';
    html += '<th>Name</th><th>Status</th><th>IP</th><th>Wallet</th><th></th>';
    html += '</tr></thead><tbody>';

    for (const s of servers) {
      const sc = s.status === 'ready' ? 'ready' : s.status === 'failed' ? 'failed' : 'provisioning';
      const badge = '<span class="status-pill status-' + sc + '"><span class="dot"></span>' + s.status + '</span>';
      const wallet = s.wallet_address
        ? '<span class="wallet">' + s.wallet_address.slice(0, 6) + '\u2026' + s.wallet_address.slice(-4) + '</span>'
        : '<span style="color:var(--text-tertiary)">\u2014</span>';

      html += '<tr>';
      html += '<td class="name-col"><a class="server-name-link" href="#" onclick="viewLogs(' + s.id + ',\'' + escHtml(s.name) + '\',\'' + escHtml(s.ipv4 || '') + '\');return false">' + escHtml(s.name) + '</a></td>';
      html += '<td>' + badge + '</td>';
      html += '<td>' + (s.ipv4 || '\u2014') + '</td>';
      html += '<td>' + wallet + '</td>';
      html += '<td style="text-align:right"><button class="btn-ghost" onclick="deleteServer(' + s.id + ')">Delete</button></td>';
      html += '</tr>';
    }

    html += '</tbody></table>';
    el.innerHTML = html;
  }

  function startPolling() {
    if (polling) return;
    polling = setInterval(refreshServers, 5000);
  }

  function stopPolling() {
    if (polling) { clearInterval(polling); polling = null; }
  }

  // Delete server
  window.deleteServer = async function (id) {
    if (!confirm('Terminate server ' + id + '?')) return;
    try {
      const res = await fetch(API + '/servers/' + id, { method: 'DELETE' });
      if (!res.ok) {
        const data = await res.json();
        alert('Delete failed: ' + (data.error || res.statusText));
        return;
      }
      refreshServers();
    } catch (err) {
      alert('Network error: ' + err.message);
    }
  };

  // HTML escaping helper
  function escHtml(s) {
    const d = document.createElement('div');
    d.textContent = s;
    return d.innerHTML;
  }

  // Log viewer (WebSocket)
  function showLogView(serverId, name, ip) {
    currentLogServerId = serverId;
    document.getElementById('main-view').classList.add('hidden');
    document.getElementById('log-view').classList.add('active');
    document.getElementById('log-server-name').textContent = name;
    document.getElementById('log-server-ip').textContent = ip;
    document.getElementById('log-terminal').textContent = '';
    document.getElementById('log-done-msg').textContent = '';
    document.getElementById('log-done-msg').innerHTML = '';
    document.getElementById('log-status-pill').innerHTML = '';
    connectWebSocket(serverId);
  }

  function hideLogView() {
    if (logWs) {
      logWs.close();
      logWs = null;
    }
    currentLogServerId = null;
    document.getElementById('log-view').classList.remove('active');
    document.getElementById('main-view').classList.remove('hidden');
    refreshServers();
  }

  document.getElementById('log-back-btn').addEventListener('click', hideLogView);

  function connectWebSocket(serverId) {
    if (logWs) {
      logWs.close();
      logWs = null;
    }

    const proto = location.protocol === 'https:' ? 'wss:' : 'ws:';
    const url = proto + '//' + location.host + '/servers/' + serverId + '/ws';
    const ws = new WebSocket(url);
    logWs = ws;

    ws.onmessage = function (evt) {
      let msg;
      try { msg = JSON.parse(evt.data); } catch (_) { return; }

      if (msg.type === 'init') {
        const srv = msg.server;
        document.getElementById('log-server-name').textContent = srv.name;
        document.getElementById('log-server-ip').textContent = srv.ipv4;
        updateLogStatusPill(srv.status);
      } else if (msg.type === 'log') {
        const terminal = document.getElementById('log-terminal');
        terminal.textContent += msg.line + '\n';
        terminal.scrollTop = terminal.scrollHeight;
      } else if (msg.type === 'status') {
        updateLogStatusPill(msg.status);
        const doneEl = document.getElementById('log-done-msg');
        if (msg.status === 'ready') {
          doneEl.innerHTML = '<span>Provisioning complete.</span>';
        } else if (msg.status === 'failed') {
          let html = '<span>Provisioning failed.</span>';
          if (!msg.default_key_removed) {
            html += ' <button class="btn-warn" id="reprovision-btn">Re-provision</button>';
          }
          doneEl.innerHTML = html;
          const btn = document.getElementById('reprovision-btn');
          if (btn) {
            btn.addEventListener('click', function () {
              reprovisionServer(serverId);
            });
          }
        }
      }
    };

    ws.onclose = function () {
      if (logWs === ws) {
        const terminal = document.getElementById('log-terminal');
        terminal.textContent += '\n[disconnected]\n';
      }
    };

    ws.onerror = function () {
      if (logWs === ws) {
        const terminal = document.getElementById('log-terminal');
        terminal.textContent += '\n[connection error]\n';
      }
    };
  }

  async function reprovisionServer(serverId) {
    const btn = document.getElementById('reprovision-btn');
    if (btn) {
      btn.disabled = true;
      btn.textContent = 'Re-provisioning...';
    }

    try {
      const res = await fetch(API + '/servers/' + serverId + '/reprovision', { method: 'POST' });
      if (!res.ok) {
        const data = await res.json();
        alert('Re-provision failed: ' + (data.error || res.statusText));
        if (btn) { btn.disabled = false; btn.textContent = 'Re-provision'; }
        return;
      }
      // Clear terminal and reconnect WS
      document.getElementById('log-terminal').textContent = '';
      document.getElementById('log-done-msg').innerHTML = '';
      updateLogStatusPill('provisioning');
      connectWebSocket(serverId);
    } catch (err) {
      alert('Network error: ' + err.message);
      if (btn) { btn.disabled = false; btn.textContent = 'Re-provision'; }
    }
  }

  // --- Pairing requests ---

  let lastServers = [];

  async function refreshPairingRequests() {
    const readyServers = lastServers.filter(s => s.status === 'ready' && s.has_node_api);
    if (readyServers.length === 0) {
      document.getElementById('pairing-section').style.display = 'none';
      return;
    }

    document.getElementById('pairing-section').style.display = '';

    const allRequests = [];
    for (const srv of readyServers) {
      try {
        const res = await signedFetch(
          '/servers/' + srv.id + '/pairing/requests',
          '/pairing/requests',
          'GET'
        );
        if (!res.ok) continue;
        const requests = await res.json();
        for (const req of requests) {
          req.server_id = srv.id;
          req.server_name = srv.name;
          allRequests.push(req);
        }
      } catch (_) {}
    }

    renderPairingRequests(allRequests);
  }

  function renderPairingRequests(requests) {
    const el = document.getElementById('pairing-list');
    const pending = requests.filter(r => r.status === 'pending');

    if (pending.length === 0) {
      el.innerHTML = '<div class="empty-state">No pending pairing requests.</div>';
      return;
    }

    let html = '<table><thead><tr>';
    html += '<th>Server</th><th>Channel</th><th>User</th><th>Requested</th><th></th>';
    html += '</tr></thead><tbody>';

    for (const r of pending) {
      html += '<tr>';
      html += '<td class="name-col" style="font-family:var(--sans)">' + escHtml(r.server_name) + '</td>';
      html += '<td>' + escHtml(r.channel) + '</td>';
      html += '<td>' + escHtml(r.user || r.id) + '</td>';
      html += '<td>' + escHtml(r.created_at || '') + '</td>';
      html += '<td><div class="pairing-actions">';
      html += '<button class="btn-approve" onclick="approvePairing(' + r.server_id + ',\'' + escHtml(r.channel) + '\',\'' + escHtml(r.id) + '\')">Approve</button>';
      html += '<button class="btn-deny" onclick="denyPairing(' + r.server_id + ',\'' + escHtml(r.channel) + '\',\'' + escHtml(r.id) + '\')">Deny</button>';
      html += '</div></td>';
      html += '</tr>';
    }

    html += '</tbody></table>';
    el.innerHTML = html;
  }

  window.approvePairing = async function (serverId, channel, id) {
    const body = JSON.stringify({ channel, id });
    try {
      const res = await signedFetch(
        '/servers/' + serverId + '/pairing/approve',
        '/pairing/approve',
        'POST',
        body
      );
      if (!res.ok) {
        const data = await res.json();
        alert('Approve failed: ' + (data.error || res.statusText));
        return;
      }
      refreshPairingRequests();
    } catch (err) {
      alert('Network error: ' + err.message);
    }
  };

  window.denyPairing = async function (serverId, channel, id) {
    const body = JSON.stringify({ channel, id });
    try {
      const res = await signedFetch(
        '/servers/' + serverId + '/pairing/deny',
        '/pairing/deny',
        'POST',
        body
      );
      if (!res.ok) {
        const data = await res.json();
        alert('Deny failed: ' + (data.error || res.statusText));
        return;
      }
      refreshPairingRequests();
    } catch (err) {
      alert('Network error: ' + err.message);
    }
  };

  function startPairingPoll() {
    if (pairingPoll) return;
    refreshPairingRequests();
    pairingPoll = setInterval(refreshPairingRequests, 30000);
  }

  function stopPairingPoll() {
    if (pairingPoll) { clearInterval(pairingPoll); pairingPoll = null; }
  }

  function updateLogStatusPill(status) {
    const sc = status === 'ready' ? 'ready' : status === 'failed' ? 'failed' : 'provisioning';
    document.getElementById('log-status-pill').innerHTML =
      '<span class="status-pill status-' + sc + '"><span class="dot"></span>' + status + '</span>';
  }

  // Global function for clickable server names
  window.viewLogs = function (id, name, ip) {
    showLogView(id, name, ip);
  };

  // Initial load
  refreshServers();
  startPolling();
})();
</script>
</body>
</html>
